<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Community Chat</title>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<!-- Firebase App (the core Firebase SDK) -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<!-- Firebase Firestore -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
<!-- Firebase Authentication -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
<!-- Firebase Realtime Database -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
<!-- Cloudinary for GIF/Sticker uploads -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/cloudinary-core/2.13.0/cloudinary-core-shrinkwrap.min.js"></script>
<style>
/* All CSS remains the same - no changes needed */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

body {
  background: linear-gradient(135deg, #6e8efb, #a777e3);
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 0;
}

.chat-container {
  width: 100%;
  height: 100%;
  background: #fff;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.chat-header {
  background: #4a6cfa;
  color: white;
  padding: 14px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
}

.header-left {
  display: flex;
  align-items: center;
}

.profile-image-container {
  position: absolute;
  margin-right:20px;
}

.profile-image {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background-color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid rgba(255, 255, 255, 0.3);
  z-index: 2;
  position: relative;
}

.profile-image i {
  color: #4a6cfa;
  font-size: 20px;
}

.profile-background {
  position: absolute;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.2);
  top: -5px;
  left: -5px;
  z-index: 1;
}

.header-info {
  display: flex;
  flex-direction: column;
}

.chat-title {
  font-weight: 600;
  font-size: 16;
  margin-bottom: 2px;
  position: relative;
  z-index: 2;
}
.online-info {
  display: flex;
  align-items: center;
  font-size: 12px;
  opacity: 0.9;
}

@keyframes blink {
  0% {
    box-shadow: 0 0 0 0 rgba(100, 206, 131, 0.7);
  }
  70% {
    box-shadow: 0 0 0 6px rgba(100, 206, 131, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(100, 206, 131, 0);
  }
}
.online-indicator {
  background: #4CAF50;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 6px;
  box-shadow: 0 0 10px rgba(100, 206, 131, 0.7);
  animation: blink 2s infinite;
}

.header-actions {
  display: flex;
  align-items: center;
  position: relative;
  z-index: 100;
}

.header-btn {
  background: none;
  border: none;
  color: white;
  font-size: 16px;
  cursor: pointer;
  margin-left: 12px;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.header-btn:hover {
  background: rgba(255, 255, 255, 0.1);
}

.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  right: 10px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
  width: 180px;
  z-index: 1000;
  overflow: hidden;
}

.dropdown-menu.show {
  display: block;
}

.dropdown-menu a {
  display: block;
  padding: 12px 16px;
  color: #333;
  text-decoration: none;
  transition: background 0.2s;
  font-size: 14px;
}

.dropdown-menu a i {
  margin-right: 8px;
  width: 16px;
  text-align: center;
}

.dropdown-menu a:hover {
  background: #f0f5ff;
  color: #4a6cfa;
}

.messages-container {
  flex: 1;
  padding: 16px;
  overflow-y: auto;
  background: #f0f2f5;
  display: flex;
  flex-direction: column;
}

.message {
  margin-bottom: 16px;
  display: flex;
  flex-direction: column;
  max-width: 85%;
  animation: fadeIn 0.3s ease;
  position: relative;
  cursor: pointer;
  transition: transform 0.2s;
}

.message.swiping {
  transform: translateX(-50px);
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.message.own {
  align-self: flex-end;
}

.message-info {
  display: flex;
  align-items: center;
  margin-bottom: 4px;
}

.message-user {
  font-size: 13px;
  font-weight: 600;
  color: #4a6cfa;
}

.message-time {
  font-size: 11px;
  color: #999;
  margin-left: 8px;
}

.message-content {
  padding: 10px 14px;
  border-radius: 18px;
  position: relative;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  line-height: 1.4;
  word-wrap: break-word;
}

.message.other .message-content {
  background: #e9e9eb;
  border-top-left-radius: 4px;
}

.message.own .message-content {
  background: #4a6cfa;
  color: white;
  border-top-right-radius: 4px;
}

.message-actions {
  display: none;
  position: absolute;
  bottom: -20px;
  right: 10px;
  background: white;
  border-radius: 4px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  z-index: 10;
}

.message:hover .message-actions {
  display: flex;
}

.message-action {
  background: none;
  border: none;
  padding: 6px 10px;
  cursor: pointer;
  font-size: 12px;
  color: #666;
  transition: color 0.2s;
}

.message-action:hover {
  color: #4a6cfa;
}

.input-container {
  display: flex;
  padding: 12px;
  background: white;
  border-top: 1px solid #e0e0e0;
  align-items: center;
}

.message-input {
  flex: 1;
  padding: 12px 16px;
  border: 1px solid #e0e0e0;
  border-radius: 24px;
  outline: none;
  font-size: 14px;
  transition: border-color 0.2s;
  margin-right: 8px;
}

.message-input:focus {
  border-color: #4a6cfa;
}

.toggle-button {
  background: #4CAF50;
  border: none;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  color: white;
  margin-left: 8px;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: background 0.2s, transform 0.2s;
}

.toggle-button.send-mode {
  background: #4a6cfa;
}

.toggle-button:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.toggle-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.voice-recording {
  display: none;
  align-items: center;
  justify-content: center;
  padding: 12px;
  background: #ffebee;
  color: #d32f2f;
  font-weight: 500;
  font-size: 14px;
}

.voice-recording.active {
  display: flex;
}

.recording-dot {
  width: 10px;
  height: 10px;
  background: #d32f2f;
  border-radius: 50%;
  margin-right: 8px;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.5; }
  100% { opacity: 1; }
}

.edit-mode {
  background: #fff8e1;
  padding: 10px 16px;
  display: none;
  justify-content: space-between;
  align-items: center;
  font-size: 14px;
  color: #5d4037;
  border-bottom: 1px solid #ffe0b2;
}

.edit-mode.active {
  display: flex;
}

.edit-mode-cancel {
  background: none;
  border: none;
  color: #5d4037;
  cursor: pointer;
  font-weight: 600;
  padding: 4px 8px;
  border-radius: 4px;
}

.edit-mode-cancel:hover {
  background: rgba(93, 64, 55, 0.1);
}

.welcome-message {
  text-align: center;
  padding: 20px;
  color: #666;
  font-style: italic;
  font-size: 14px;
}

.voice-message-indicator {
  display: flex;
  align-items: center;
  padding: 18px 12px;
  background: rgba(0, 0, 0, 0.05);
  border-radius: 50px;
  margin-top: 4px;
}

.voice-message-indicator i {
  margin-right: 8px;
  color: #4a6cfa;
}

.system-notification {
  text-align: center;
  font-size: 12px;
  color: #999;
  margin: 8px 0;
  font-style: italic;
}

.typing-indicator {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  background: #e9e9eb;
  border-radius: 18px;
  align-self: flex-start;
  margin-bottom: 16px;
  max-width: 100px;
}

.typing-dot {
  width: 6px;
  height: 6px;
  background: #999;
  border-radius: 50%;
  margin-right: 4px;
  animation: typingAnimation 1.4s infinite;
}

.typing-dot:nth-child(2) {
  animation-delay: 0.2s;
}

.typing-dot:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes typingAnimation {
  0%, 60%, 100% { transform: translateY(0); }
  30% { transform: translateY(-4px); }
}

.notification {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: white;
  padding: 12px 20px;
  border-radius: 4px;
  z-index: 1000;
  opacity: 0;
  transition: opacity 0.3s;
}

.notification.show {
  opacity: 1;
}
.loading {
  text-align: center;
  padding: 20px;
  color: #666;
}

.loading-spinner {
  border: 3px solid #f3f3f3;
  border-top: 3px solid #4a6cfa;
  border-radius: 50%;
  width: 30px;
  height: 30px;
  animation: spin 1s linear infinite;
  margin: 0 auto 10px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}                                     
.admin-panel {
  background: #f5f5f5;
  padding: 10px;
  border-bottom: 1px solid #e0e0e0;
  display: none;
}

.admin-panel.active {
  display: block;
}

.admin-btn {
  background: #ff5722;
  color: white;
  border: none;
  padding: 8px 12px;
  border-radius: 4px;
  cursor: pointer;
  margin-right: 8px;
  font-size: 12px;
}

/* Hide Firebase internal elements */
.firebase-auto-detect {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  height: 0 !important;
  width: 0 !important;
  position: absolute !important;
  top: -9999px !important;
  left: -9999px !important;
}

.recording-timer {
  margin-left: 10px;
  font-weight: bold;
}

.search-container {
  display: none;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: white;
  z-index: 1000;
  padding: 10px;
  flex-direction: column;
}

.search-container.active {
  display: flex;
}

.search-header {
  display: flex;
  align-items: center;
  margin-bottom: 15px;
}

.search-input {
  flex: 1;
  padding: 10px 15px;
  border: 1px solid #e0e0e0;
  border-radius: 20px;
  outline: none;
  font-size: 14px;
}

.close-search {
  background: none;
  border: none;
  font-size: 20px;
  margin-left: 10px;
  cursor: pointer;
}

.search-results {
  flex: 1;
  overflow-y: auto;
}

.cancel-recording-btn {
  margin-left: 10px; 
  background: #ff5722; 
  color: white; 
  border: none; 
  padding: 4px 8px; 
  border-radius: 4px; 
  font-size: 12px;
  cursor: pointer;
}

/* Image and Video Preview Styles */
.file-preview-container {
  margin-top: 8px;
  max-width: 100%;
}

.image-preview {
  max-width: 100%;
  max-height: 300px;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.3s;
  display: block;
}

.image-preview:hover {
  transform: scale(1.02);
}

.video-player {
  width: 100%;
  max-width: 400px;
  border-radius: 8px;
  background: #000;
  max-height: 300px;
}

/* Image Modal for Fullscreen View */
.image-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  z-index: 3000;
  justify-content: center;
  align-items: center;
}

.image-modal.active {
  display: flex;
}

.image-modal-content {
  max-width: 90%;
  max-height: 90%;
}

.image-modal-img {
  max-width: 100%;
  max-height: 100%;
  border-radius: 8px;
}

.image-modal-close {
  position: absolute;
  top: 20px;
  right: 20px;
  background: rgba(255, 255, 255, 0.2);
  border: none;
  color: white;
  font-size: 24px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}

.image-modal-close:hover {
  background: rgba(255, 255, 255, 0.3);
}

/* Audio player styles */
.audio-player {
  width: 100%;
  max-width: 300px;
  margin-top: 8px;
  border-radius: 8px;
}

/* Document file styles */
.document-file {
  display: flex;
  align-items: center;
  padding: 12px;
  background: #f8f9fa;
  border-radius: 8px;
  margin-top: 8px;
  border-left: 4px solid #4a6cfa;
  cursor: pointer;
  transition: background 0.3s;
}

.document-file:hover {
  background: #e9ecef;
}

.document-icon {
  font-size: 24px;
  color: #4a6cfa;
  margin-right: 12px;
}

.document-info {
  flex: 1;
}

.document-name {
  font-weight: 600;
  margin-bottom: 4px;
  word-break: break-word;
  color: #4a6cfa;
}

.document-size {
  font-size: 12px;
  color: #666;
}

/* Emoji Reactions Styles - UPDATED FOR BETTER VISIBILITY */
.message-reactions {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin-top: 8px;
  padding: 4px 0;
  min-height: 24px;
  background: rgba(255, 255, 255, 0.7);
  border-radius: 12px;
  padding: 4px 8px;
}

.reaction-item {
  display: flex;
  align-items: center;
  gap: 2px;
  padding: 2px 6px;
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid #e0e0e0;
  border-radius: 12px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
  user-select: none;
}

.reaction-item:hover {
  background: rgba(74, 108, 250, 0.1);
  border-color: #4a6cfa;
  transform: translateY(-1px);
}

.reaction-item.own-reaction {
  background: rgba(74, 108, 250, 0.15);
  border-color: #4a6cfa;
  box-shadow: 0 1px 3px rgba(74, 108, 250, 0.2);
}

.reaction-emoji {
  font-size: 14px;
}

.reaction-count {
  font-size: 11px;
  font-weight: 600;
  color: #666;
  min-width: 12px;
  text-align: center;
}

/* Emoji Picker Styles - FIXED POSITIONING */
.emoji-picker-container {
  position: fixed;
  z-index: 2000;
  background: white;
  border-radius: 12px;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
  padding: 12px;
  display: none;
  flex-direction: column;
  width: 320px;
  max-height: 400px;
}

.emoji-picker-container.active {
  display: flex;
  animation: slideInUp 0.2s ease;
}

@keyframes slideInUp {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.emoji-picker-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  padding-bottom: 8px;
  border-bottom: 1px solid #e0e0e0;
}

.emoji-picker-title {
  font-weight: 600;
  color: #333;
  font-size: 14px;
}

.emoji-picker-close {
  background: none;
  border: none;
  color: #666;
  cursor: pointer;
  font-size: 16px;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.emoji-picker-close:hover {
  background: #f0f0f0;
}

.emoji-categories {
  display: flex;
  gap: 4px;
  margin-bottom: 10px;
  border-bottom: 1px solid #e0e0e0;
  padding-bottom: 8px;
}

.emoji-category-btn {
  background: none;
  border: none;
  padding: 6px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 16px;
  transition: background 0.2s;
}

.emoji-category-btn:hover,
.emoji-category-btn.active {
  background: #f0f5ff;
}

.emoji-grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 6px;
  overflow-y: auto;
  padding: 5px;
  flex: 1;
}

.emoji-btn {
  background: none;
  border: none;
  width: 32px;
  height: 32px;
  font-size: 20px;
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.emoji-btn:hover {
  background: #f0f5ff;
  transform: scale(1.1);
}

/* Long press detection */
.long-press-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.3);
  z-index: 1999;
  display: none;
  align-items: center;
  justify-content: center;
}

.long-press-overlay.active {
  display: flex;
}

.long-press-message {
  background: white;
  padding: 20px 30px;
  border-radius: 12px;
  text-align: center;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
  animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.long-press-emoji {
  font-size: 32px;
  margin-bottom: 10px;
}

.long-press-text {
  color: #333;
  font-weight: 500;
}

/* Message content with reaction support */
.message-content.has-reactions {
  padding-bottom: 4px;
}

/* GIF/Sticker Styles */
.gif-sticker-picker {
  position: fixed;
  bottom: 80px;
  left: 0;
  right: 0;
  background: white;
  border-radius: 12px 12px 0 0;
  box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.15);
  display: none;
  flex-direction: column;
  max-height: 400px;
  z-index: 1500;
}

.gif-sticker-picker.active {
  display: flex;
  animation: slideUp 0.3s ease;
}

@keyframes slideUp {
  from {
    transform: translateY(100%);
  }
  to {
    transform: translateY(0);
  }
}

.gif-sticker-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid #e0e0e0;
}

.gif-sticker-tabs {
  display: flex;
  gap: 8px;
  border-bottom: 1px solid #e0e0e0;
}

.gif-sticker-tab {
  flex: 1;
  padding: 12px;
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  cursor: pointer;
  font-weight: 500;
  color: #666;
}

.gif-sticker-tab.active {
  border-bottom-color: #4a6cfa;
  color: #4a6cfa;
}

.gif-sticker-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 8px;
  padding: 12px;
  overflow-y: auto;
  flex: 1;
}

.gif-sticker-item {
  width: 100%;
  height: 80px;
  object-fit: cover;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.2s;
}

.gif-sticker-item:hover {
  transform: scale(1.05);
}

/* Reply Preview Styles */
.reply-preview {
  display: none;
  padding: 10px 16px;
  background: #f0f5ff;
  border-bottom: 1px solid #4a6cfa;
  align-items: center;
  justify-content: space-between;
}

.reply-preview.active {
  display: flex;
}

.reply-preview-content {
  flex: 1;
  margin-right: 12px;
  font-size: 13px;
}

.reply-preview-user {
  font-weight: 600;
  color: #4a6cfa;
  margin-bottom: 2px;
}

.reply-preview-text {
  color: #666;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.reply-preview-cancel {
  background: none;
  border: none;
  color: #ff5722;
  cursor: pointer;
  font-size: 14px;
  padding: 4px 8px;
  border-radius: 4px;
}

.reply-preview-cancel:hover {
  background: rgba(255, 87, 34, 0.1);
}

/* Message Reply Styles */
.message-reply {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  background: rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  margin-bottom: 8px;
  border-left: 3px solid #4a6cfa;
  cursor: pointer;
  transition: background 0.2s;
}

.message-reply:hover {
  background: rgba(255, 255, 255, 0.4);
}

.reply-indicator {
  display: flex;
  align-items: center;
  margin-bottom: 4px;
  font-size: 11px;
  color: #666;
}

.reply-indicator i {
  margin-right: 4px;
  font-size: 10px;
}

.reply-content {
  font-size: 12px;
  line-height: 1.3;
  word-break: break-word;
}

.reply-content.media-reply {
  color: #4a6cfa;
  font-style: italic;
}

/* Swipe to Reply Indicator - IMPROVED */
.swipe-indicator {
  position: absolute;
  right: -60px;
  top: 50%;
  transform: translateY(-50%);
  background: #4a6cfa;
  color: white;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 12px;
  display: flex;
  align-items: center;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.3s;
  pointer-events: none;
  z-index: 10;
  white-space: nowrap;
}

.message.swiping .swipe-indicator {
  opacity: 1;
}

/* Touch device optimization */
@media (max-width: 768px) {
  .emoji-grid {
    grid-template-columns: repeat(6, 1fr);
    gap: 4px;
  }
  
  .emoji-btn {
    width: 36px;
    height: 36px;
    font-size: 22px;
  }
  
  .emoji-picker-container {
    width: 90vw;
    max-width: none;
    left: 50% !important;
    right: auto !important;
    bottom: auto !important;
    top: 50px !important;
    transform: translateX(-50%) !important;
  }
  
  .gif-sticker-grid {
    grid-template-columns: repeat(3, 1fr);
  }
  
  .gif-sticker-item {
    height: 70px;
  }
}

@media (max-width: 480px) {
  .emoji-grid {
    grid-template-columns: repeat(5, 1fr);
  }
  
  .emoji-btn {
    width: 40px;
    height: 40px;
  }
  
  .gif-sticker-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}
/* Responsive Desktop Styles */
@media screen and (max-width: 1200px) {
.chat-container {
  width: 100% ! important;
  height:100% ! important;
  width: 90%;
  height: 90vh;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
  margin:none;
}

/* Header responsiveness */
.chat-header {
  padding: 16px 24px;
}

.profile-image {
  width: 45px;
  height: 45px;
}

.profile-image i {
  font-size: 22px;
}

.chat-title {
  font-size: 18px;
}

.online-info {
  font-size: 13px;
}

/* Messages container */
.messages-container {
  padding: 20px;
}

.message {
  max-width: 70%;
}

/* Input area */
.input-container {
  padding: 16px 24px;
}

.message-input {
  padding: 14px 18px;
  font-size: 15px;
}

.toggle-button {
  width: 45px;
  height: 45px;
}

/* Edit mode */
.edit-mode {
  padding: 12px 24px;
}

/* Voice recording */
.voice-recording {
  padding: 14px 24px;
}

/* Dropdown menu */
.dropdown-menu {
  width: 200px;
}

/* Search container */
.search-container {
  padding: 20px;
}

.search-input {
  padding: 12px 18px;
  font-size: 15px;
}
  }
/* Media queries for different desktop sizes */
@media screen and (max-width: 1400px) {
  .chat-container {
    width: 95%;
    height: 92vh;
  }
}

@media screen and (max-width: 1200px) {
  .message {
    max-width: 75%;
  }
}

@media screen and (max-width: 1024px) {
  .chat-container {
    width: 98%;
    height: 94vh;
  }
  
  .messages-container {
    padding: 16px;
  }
  
  .message {
    max-width: 80%;
  }
}

@media screen and (max-width: 900px) {
  .chat-header {
    padding: 14px 20px;
  }
  
  .input-container {
    padding: 14px 20px;
  }
  
  .message {
    max-width: 85%;
  }
}

/* Large desktop screens */
@media screen and (min-width: 1600px) {
  .chat-container {
    max-width: 1400px;
  }
  
  .messages-container {
    padding: 24px;
  }
  
  .message {
    max-width: 65%;
  }
}

@media screen and (min-width: 1920px) {
  .chat-container {
    max-width: 1600px;
  }
  
  .message {
    max-width: 60%;
  }
}

/* High DPI screens */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
  .chat-container {
    border: 1px solid #e0e0e0;
  }
}

/* Adjustments for hover states on devices that support hover */
@media (hover: hover) {
  .header-btn:hover {
    background: rgba(255, 255, 255, 0.15);
    transform: scale(1.05);
  }
  
  .toggle-button:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
  }
  
  .message-action:hover {
    background: #f0f5ff;
    border-radius: 4px;
  }
  }
@media (max-width: 992px) {
  .chat-container {
    width: 95%;
    height: 92vh;
  }
  
  .message {
    max-width: 90%;
  }
}

@media (max-width: 768px) {
  body {
    padding: 0;
    display: block;
  }
  
  .chat-container {
    width: 100%;
    height: 100vh;
    border-radius: 0;
    position: fixed;
    top: 0;
    left: 0;
  }
  
  .chat-header {
    padding: 12px 15px;
    position: sticky;
    top: 0;
    z-index: 100;
  }
  
  .messages-container {
    flex: 1;
    padding: 15px 10px;
    padding-bottom: 70px; /* Space for input */
  }
  
  .input-container {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 10px 15px;
    background: white;
    border-top: 1px solid #e0e0e0;
    z-index: 100;
  }
  
  .message {
    max-width: 85%;
  }
  
  .message-content {
    padding: 10px 14px;
    font-size: 15px;
  }
  
  .header-btn {
    width: 38px;
    height: 38px;
  }
  
  .toggle-button {
    width: 44px;
    height: 44px;
  }
  
  .image-preview {
    max-height: 200px;
  }
  
  .video-player {
    max-width: 100%;
    max-height: 200px;
  }
  
  .audio-player {
    max-width: 100%;
  }
  
  .gif-sticker-picker {
    max-height: 300px;
  }
  
  .gif-sticker-item {
    height: 60px;
  }
}

@media (max-width: 576px) {
  .chat-header {
    padding: 12px 12px;
  }
  
  .profile-image {
    width: 36px;
    height: 36px;
  }
  
  .profile-image i {
    font-size: 18px;
  }
  
  .chat-title {
    font-size: 16px;
  }
  
  .online-info {
    font-size: 12px;
  }
  
  .header-btn {
    width: 36px;
    height: 36px;
    font-size: 15px;
  }
  
  .message {
    max-width: 90%;
  }
  
  .message-content {
    padding: 8px 12px;
    font-size: 14px;
  }
  
  .message-user {
    font-size: 13px;
  }
  
  .message-time {
    font-size: 11px;
  }
  
  .input-container {
    padding:6px 2px;
  }
  
  .message-input {
    padding:none;
    font-size: 15px;
  }
  
  .toggle-button {
    width: 50px;
    height: 50px;
    font-size: 16px;
  }
  
  .dropdown-menu {
    width: 200px;
    right: 5px;
  }
  
  .gif-sticker-picker {
    max-height: 250px;
  }
  
  .gif-sticker-item {
    height: 50px;
  }
}

@media (max-width: 400px) {
  .header-info {
    max-width: 60%;
  }
  
  .chat-title {
    font-size: 15px;
  }
  
  .online-info {
    font-size: 11px;
  }
  
  .message {
    max-width: 95%;
  }
  
  .message-content {
    padding: 8px 10px;
  }
  
  .message-input {
    padding: 10px 14px;
  }
  
  .toggle-button {
    width: 40px;
    height: 40px;
  }
}

/* Fix for mobile viewport units */
@media (max-height: 700px) {
  .chat-container {
    height: 100vh;
    width:100%
  }
  
  .messages-container {
    padding-bottom: 80px;
  }
  
  .gif-sticker-picker {
    max-height: 250px;
  }
}

/* Prevent zoom on input focus for mobile */
@media (max-width: 768px) {
  input, textarea {
    font-size: 16px !important; /* Prevent zoom on iOS */
  }
}

  .input-container {
    padding-bottom: max(10px, env(safe-area-inset-bottom));
  }
</style>
</head>
<body>
<!-- Image Preview Modal -->
<div class="image-modal" id="image-modal">
  <button class="image-modal-close" id="image-modal-close">
    <i class="fas fa-times"></i>
  </button>
  <div class="image-modal-content">
    <img class="image-modal-img" id="image-modal-img" src="" alt="Fullscreen preview">
  </div>
</div>

<!-- GIF/Sticker Picker -->
<div class="gif-sticker-picker" id="gif-sticker-picker">
  <div class="gif-sticker-header">
    <h3 style="font-size: 16px; margin: 0;">GIFs & Stickers</h3>
    <button id="close-gif-picker" style="background: none; border: none; font-size: 20px; cursor: pointer;">
      <i class="fas fa-times"></i>
    </button>
  </div>
  <div class="gif-sticker-tabs">
    <button class="gif-sticker-tab active" data-type="gif">GIFs</button>
    <button class="gif-sticker-tab" data-type="sticker">Stickers</button>
  </div>
  <div class="gif-sticker-grid" id="gif-sticker-grid">
    <!-- GIFs and stickers will be loaded here -->
  </div>
</div>

<div class="notification" id="notification"></div>

<div class="chat-container" id="chat-container">
  <div class="search-container" id="search-container">
    <div class="search-header">
      <input type="text" class="search-input" id="search-input" placeholder="Search by user ID or type 'admin' for admin messages...">
      <button class="close-search" id="close-search"><i class="fas fa-times"></i></button>
    </div>
    <div class="search-results" id="search-results"></div>
  </div>

  <div class="chat-header">
    <div class="profile-image">
      <i class="fas fa-user"></i>
    </div>

    <div class="header-info">
      <div class="chat-title">Portaflux Community Forum</div>
      <div class="online-info">
        <div class="online-indicator"></div>
        <span id="online-count">0 online</span>
      </div>
    </div>

    <div class="header-actions">
      <button class="header-btn" id="search-btn">
        <i class="fas fa-search"></i>
      </button>
      <button class="header-btn" id="gif-sticker-btn" title="GIFs & Stickers">
        <i class="fas fa-smile"></i>
      </button>
      <button class="header-btn" id="menu-toggle">
        <i class="fas fa-ellipsis-v"></i>
      </button>
    </div>

    <div class="dropdown-menu" id="dropdown-menu">
      <a href="#" id="about-link"><i class="fas fa-info-circle"></i> About Us</a>
      <a href="#" id="privacy-link"><i class="fas fa-shield-alt"></i> Privacy Policy</a>
    </div>
  </div>

  <!-- Reply Preview -->
  <div class="reply-preview" id="reply-preview">
    <div class="reply-preview-content">
      <div class="reply-preview-user" id="reply-preview-user"></div>
      <div class="reply-preview-text" id="reply-preview-text"></div>
    </div>
    <button class="reply-preview-cancel" id="reply-preview-cancel">
      <i class="fas fa-times"></i> Cancel
    </button>
  </div>

  <div class="edit-mode" id="edit-mode">
    <div class="edit-mode-text">Editing message</div>
    <button class="edit-mode-cancel" id="edit-cancel">Cancel</button>
  </div>

  <div class="voice-recording" id="voice-recording">
    <div class="recording-dot"></div>
    <span id="recording-text">Recording... </span>
    <span id="recording-timer" class="recording-timer">0:00</span>
    <button id="cancel-recording" class="cancel-recording-btn">Cancel</button>
  </div>

  <div class="messages-container" id="messages-container">
    <div class="loading">
      <div class="loading-spinner"></div>
      <p>Loading messages...</p>
    </div>
  </div>

  <div class="input-container">
    <input type="text" class="message-input" id="message-input" placeholder="Type your message..." disabled>
    <button class="toggle-button" id="toggle-button" disabled>
      <i class="fas fa-microphone"></i>
    </button>
  </div>
  
  <!-- Long Press Overlay -->
  <div class="long-press-overlay" id="long-press-overlay">
    <div class="long-press-message">
      <div class="long-press-emoji">ðŸ‘†</div>
      <div class="long-press-text">Hold to react</div>
    </div>
  </div>
  
  <!-- Emoji Picker -->
  <div class="emoji-picker-container" id="emoji-picker">
    <div class="emoji-picker-header">
      <div class="emoji-picker-title">React with emoji</div>
      <button class="emoji-picker-close" id="emoji-picker-close">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="emoji-categories" id="emoji-categories">
      <!-- Categories will be added dynamically -->
    </div>
    <div class="emoji-grid" id="emoji-grid">
      <!-- Emojis will be added dynamically -->
    </div>
  </div>
</div>

<script>
// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyDCWEYC9mzmz1ayVneqw26a6nKal9fahoc",
  authDomain: "portaflux-59543.firebaseapp.com",
  projectId: "portaflux-59543",
  storageBucket: "portaflux-59543.firebasestorage.app",
  messagingSenderId: "130551479322",
  appId: "1:130551479322:web:65476a2decb8c48fc065a3",
  databaseURL: "https://portaflux-59543-default-rtdb.firebaseio.com/"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
const auth = firebase.auth();
const realtimeDb = firebase.database();

// Cloudinary Configuration
const cloudinaryConfig = {
  cloudName: 'ds2d1x3j2',
  uploadPreset: 'Admin_upload_files'
};

// DOM Elements
const menuToggle = document.getElementById('menu-toggle');
const dropdownMenu = document.getElementById('dropdown-menu');
const messagesContainer = document.getElementById('messages-container');
const messageInput = document.getElementById('message-input');
const toggleButton = document.getElementById('toggle-button');
const voiceRecording = document.getElementById('voice-recording');
const recordingText = document.getElementById('recording-text');
const recordingTimer = document.getElementById('recording-timer');
const cancelRecording = document.getElementById('cancel-recording');
const onlineCount = document.getElementById('online-count');
const editMode = document.getElementById('edit-mode');
const editCancel = document.getElementById('edit-cancel');
const searchBtn = document.getElementById('search-btn');
const notification = document.getElementById('notification');
const searchContainer = document.getElementById('search-container');
const searchInput = document.getElementById('search-input');
const closeSearch = document.getElementById('close-search');
const searchResults = document.getElementById('search-results');
const gifStickerBtn = document.getElementById('gif-sticker-btn');
const gifStickerPicker = document.getElementById('gif-sticker-picker');
const closeGifPicker = document.getElementById('close-gif-picker');
const gifStickerGrid = document.getElementById('gif-sticker-grid');
const gifStickerTabs = document.querySelectorAll('.gif-sticker-tab');
const replyPreview = document.getElementById('reply-preview');
const replyPreviewUser = document.getElementById('reply-preview-user');
const replyPreviewText = document.getElementById('reply-preview-text');
const replyPreviewCancel = document.getElementById('reply-preview-cancel');

// Image Modal Elements
const imageModal = document.getElementById('image-modal');
const imageModalImg = document.getElementById('image-modal-img');
const imageModalClose = document.getElementById('image-modal-close');

// State variables
let emojiPicker = null;
let emojiPickerVisible = false;
let currentMessageForReaction = null;
let currentMessageElementForReaction = null;
let longPressTimer = null;
let touchStartTime = 0;
let reactionsListeners = new Map();
let emojiCategories = {};
let currentUser = null;
let onlineUsers = 0;
let isRecording = false;
let mediaRecorder = null;
let audioChunks = [];
let editMessageId = null;
let messagesListener = null;
let onlineUsersListener = null;
let recordingInterval = null;
let recordingSeconds = 0;
let allMessages = [];
let isCancelingRecording = false;
let mediaStream = null;
let userPresenceRef = null;
let isUserOnline = false;
let onlineInterval = null;
let gifStickerPickerVisible = false;
let currentReplyTo = null;
let replyToMessage = null;
let touchStartX = 0;
let touchCurrentX = 0;
let isSwiping = false;
let currentSwipeMessage = null;
let swipeStartX = 0;
let swipeStartY = 0;

// Predefined GIFs and Stickers
const gifs = [
  'https://media.giphy.com/media/3o7abAHdYvZdBNnGZq/giphy.gif',
  'https://media.giphy.com/media/l0MYt5jPR6QX5pnqM/giphy.gif',
  'https://media.giphy.com/media/26tknCqiJrBQG6DrC/giphy.gif',
  'https://media.giphy.com/media/l0MYEqEzwMWFCg8rm/giphy.gif',
  'https://media.giphy.com/media/xT0xeJpnrWC4XWblEk/giphy.gif',
  'https://media.giphy.com/media/3o7TKsQ8gTp3WqXqjq/giphy.gif',
  'https://media.giphy.com/media/l0MYNB04rBb51QNtC/giphy.gif',
  'https://media.giphy.com/media/26tPgy3p5s3h9QqKY/giphy.gif',
  'https://media.giphy.com/media/l0MYC0LajbaPoEADu/giphy.gif',
  'https://media.giphy.com/media/3o7TKz8a8XWv7WQkqo/giphy.gif',
  'https://media.giphy.com/media/l0MYQ5n0p4LwLqkru/giphy.gif',
  'https://media.giphy.com/media/26tP4oKq0m0VWvKnu/giphy.gif'
];

const stickers = [
  'https://cdn-icons-png.flaticon.com/512/742/742752.png',
  'https://cdn-icons-png.flaticon.com/512/742/742751.png',
  'https://cdn-icons-png.flaticon.com/512/742/742750.png',
  'https://cdn-icons-png.flaticon.com/512/742/742749.png',
  'https://cdn-icons-png.flaticon.com/512/742/742748.png',
  'https://cdn-icons-png.flaticon.com/512/742/742747.png',
  'https://cdn-icons-png.flaticon.com/512/742/742746.png',
  'https://cdn-icons-png.flaticon.com/512/742/742745.png',
  'https://cdn-icons-png.flaticon.com/512/742/742744.png',
  'https://cdn-icons-png.flaticon.com/512/742/742743.png',
  'https://cdn-icons-png.flaticon.com/512/742/742742.png',
  'https://cdn-icons-png.flaticon.com/512/742/742741.png'
];

// Initialize the chat with proper error handling
async function initChat() {
  try {
    console.log('Initializing chat...');
    
    // Show loading state
    messagesContainer.innerHTML = `
      <div class="loading">
        <div class="loading-spinner"></div>
        <p>Loading messages...</p>
      </div>
    `;

    // Wait for Firebase to be ready
    await new Promise(resolve => {
      const unsubscribe = auth.onAuthStateChanged(user => {
        unsubscribe();
        resolve(user);
      });
    });

    // Sign in anonymously with retry logic
    let signInAttempts = 0;
    const maxSignInAttempts = 3;
    
    while (signInAttempts < maxSignInAttempts) {
      try {
        const userCredential = await auth.signInAnonymously();
        currentUser = userCredential.user;
        console.log('Anonymous sign-in successful:', currentUser.uid);
        break;
      } catch (error) {
        signInAttempts++;
        console.error(`Sign-in attempt ${signInAttempts} failed:`, error);
        if (signInAttempts === maxSignInAttempts) {
          throw new Error('Failed to sign in anonymously after multiple attempts');
        }
        // Wait before retrying
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Enable input fields
    messageInput.disabled = false;
    toggleButton.disabled = false;

    // Set up event listeners first
    setupEventListeners();

    // Initialize components
    initAudioRecording();
    setupImageModalListeners();
    initEmojiPicker();
    initGifStickerPicker();
    initSwipeToReply();

    // Set up user presence
    setupUserPresence();

    // Set up real-time listeners AFTER authentication is complete
    setupRealTimeListeners();

    // Remove loading indicator
    const loadingIndicator = document.querySelector('.loading');
    if (loadingIndicator) {
      loadingIndicator.remove();
    }

    // Show welcome message if no messages after a short delay
    setTimeout(() => {
      if (messagesContainer.children.length === 0) {
        const welcomeMsg = document.createElement('div');
        welcomeMsg.classList.add('welcome-message');
        welcomeMsg.innerHTML = `
          <i class="fas fa-comments" style="font-size: 24px; margin-bottom: 10px;"></i>
          <p>Welcome to the community chat!</p>
          <p>Start a conversation by typing a message below.</p>
        `;
        messagesContainer.appendChild(welcomeMsg);
      }
    }, 1000);

    console.log('Chat initialization complete');
  } catch (error) {
    console.error('Error initializing chat:', error);
    showNotification('Error connecting to chat: ' + error.message, 'error');
    
    // Show error state with retry option
    messagesContainer.innerHTML = `
      <div class="welcome-message">
        <i class="fas fa-exclamation-triangle" style="font-size: 24px; margin-bottom: 10px; color: #f44336;"></i>
        <p>Error connecting to chat</p>
        <p>Please check your internet connection and refresh the page</p>
        <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: #4a6cfa; color: white; border: none; border-radius: 5px; cursor: pointer;">
          <i class="fas fa-redo"></i> Retry Connection
        </button>
      </div>
    `;
  }
}

// Initialize GIF/Sticker picker
function initGifStickerPicker() {
  // Load initial GIFs
  loadGifs();
  
  // Tab switching
  gifStickerTabs.forEach(tab => {
    tab.addEventListener('click', () => {
      gifStickerTabs.forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      
      if (tab.dataset.type === 'gif') {
        loadGifs();
      } else {
        loadStickers();
      }
    });
  });
  
  // Close picker
  closeGifPicker.addEventListener('click', hideGifStickerPicker);
  
  // Close when clicking outside
  document.addEventListener('click', (e) => {
    if (gifStickerPickerVisible && !gifStickerPicker.contains(e.target) && 
        e.target !== gifStickerBtn && !gifStickerBtn.contains(e.target)) {
      hideGifStickerPicker();
    }
  });
}

// Load GIFs
function loadGifs() {
  gifStickerGrid.innerHTML = '';
  
  gifs.forEach((gifUrl, index) => {
    const gifItem = document.createElement('img');
    gifItem.className = 'gif-sticker-item';
    gifItem.src = gifUrl;
    gifItem.alt = `GIF ${index + 1}`;
    gifItem.loading = 'lazy';
    
    gifItem.addEventListener('click', () => {
      sendGifSticker(gifUrl, 'gif', 'image/gif');
      hideGifStickerPicker();
    });
    
    gifStickerGrid.appendChild(gifItem);
  });
}

// Load stickers
function loadStickers() {
  gifStickerGrid.innerHTML = '';
  
  stickers.forEach((stickerUrl, index) => {
    const stickerItem = document.createElement('img');
    stickerItem.className = 'gif-sticker-item';
    stickerItem.src = stickerUrl;
    stickerItem.alt = `Sticker ${index + 1}`;
    
    stickerItem.addEventListener('click', () => {
      sendGifSticker(stickerUrl, 'sticker', 'image/png');
      hideGifStickerPicker();
    });
    
    gifStickerGrid.appendChild(stickerItem);
  });
}

// Send GIF or Sticker - FIXED VERSION
async function sendGifSticker(fileUrl, fileType, mimeType) {
  try {
    const fileName = `${fileType}-${Date.now()}.${mimeType.split('/')[1]}`;
    
    // Send to serverless function
    const response = await fetch('/.netlify/functions/send-admin-message24', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message: `Sent a ${fileType}`,
        userId: currentUser.uid,
        fileUrl: fileUrl,
        fileName: fileName,
        fileType: mimeType,
        replyTo: currentReplyTo || null
      }),
    });

    const result = await response.json();
    
    if (!response.ok) {
      throw new Error(result.error);
    }

    // Clear reply if any
    clearReply();
    
    showNotification(`${fileType === 'gif' ? 'GIF' : 'Sticker'} sent successfully`);
  } catch (error) {
    console.error('Error sending GIF/Sticker:', error);
    showNotification('Error sending: ' + error.message, 'error');
  }
}

// Show GIF/Sticker picker
function showGifStickerPicker() {
  gifStickerPicker.classList.add('active');
  gifStickerPickerVisible = true;
  document.body.style.overflow = 'hidden';
}

// Hide GIF/Sticker picker
function hideGifStickerPicker() {
  gifStickerPicker.classList.remove('active');
  gifStickerPickerVisible = false;
  document.body.style.overflow = '';
}

// Initialize swipe to reply - IMPROVED VERSION
function initSwipeToReply() {
  let touchStartX = 0;
  let touchStartY = 0;
  let currentSwipeElement = null;
  let isSwiping = false;
  
  // Touch events for mobile
  messagesContainer.addEventListener('touchstart', (e) => {
    const messageElement = e.target.closest('.message');
    if (messageElement && !e.target.closest('.message-actions') && 
        !e.target.closest('.message-reactions') && !e.target.closest('.message-reply')) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
      currentSwipeElement = messageElement;
      isSwiping = false;
    }
  });
  
  messagesContainer.addEventListener('touchmove', (e) => {
    if (!currentSwipeElement) return;
    
    const touchCurrentX = e.touches[0].clientX;
    const touchCurrentY = e.touches[0].clientY;
    const deltaX = touchStartX - touchCurrentX;
    const deltaY = Math.abs(touchStartY - touchCurrentY);
    
    // Only trigger if horizontal swipe is greater than vertical (30px threshold)
    if (Math.abs(deltaX) > 30 && Math.abs(deltaX) > deltaY) {
      e.preventDefault();
      isSwiping = true;
      currentSwipeElement.classList.add('swiping');
      
      // Limit swipe distance to 100px
      const swipeDistance = Math.min(Math.abs(deltaX), 100);
      currentSwipeElement.style.transform = `translateX(-${swipeDistance}px)`;
      
      // Add swipe indicator if not already present
      let swipeIndicator = currentSwipeElement.querySelector('.swipe-indicator');
      if (!swipeIndicator) {
        swipeIndicator = document.createElement('div');
        swipeIndicator.className = 'swipe-indicator';
        swipeIndicator.innerHTML = '<i class="fas fa-reply"></i> Reply';
        currentSwipeElement.appendChild(swipeIndicator);
      }
      
      swipeIndicator.style.opacity = Math.min(swipeDistance / 80, 1);
    }
  });
  
  messagesContainer.addEventListener('touchend', (e) => {
    if (!currentSwipeElement) return;
    
    const touchEndX = e.changedTouches[0].clientX;
    const deltaX = touchStartX - touchEndX;
    
    // Remove swipe indicator
    const swipeIndicator = currentSwipeElement.querySelector('.swipe-indicator');
    if (swipeIndicator) {
      swipeIndicator.remove();
    }
    
    // If swipe is significant enough (60px), trigger reply
    if (isSwiping && deltaX > 60) {
      const messageId = currentSwipeElement.id.replace('message-', '');
      const message = allMessages.find(m => m.id === messageId);
      if (message) {
        setReplyTo(message);
        // Add haptic feedback on mobile
        if (window.navigator.vibrate) {
          window.navigator.vibrate(50);
        }
      }
    }
    
    // Reset
    currentSwipeElement.classList.remove('swiping');
    currentSwipeElement.style.transform = '';
    currentSwipeElement = null;
    isSwiping = false;
  });
  
  // Mouse events for desktop
  messagesContainer.addEventListener('mousedown', (e) => {
    const messageElement = e.target.closest('.message');
    if (messageElement && !e.target.closest('.message-actions') && 
        !e.target.closest('.message-reactions') && !e.target.closest('.message-reply') && e.button === 0) {
      touchStartX = e.clientX;
      touchStartY = e.clientY;
      currentSwipeElement = messageElement;
      isSwiping = false;
    }
  });
  
  messagesContainer.addEventListener('mousemove', (e) => {
    if (!currentSwipeElement || e.buttons !== 1) return;
    
    const deltaX = touchStartX - e.clientX;
    const deltaY = Math.abs(touchStartY - e.clientY);
    
    if (deltaX > 30 && deltaX > deltaY) {
      isSwiping = true;
      currentSwipeElement.classList.add('swiping');
      
      const swipeDistance = Math.min(deltaX, 100);
      currentSwipeElement.style.transform = `translateX(-${swipeDistance}px)`;
      
      let swipeIndicator = currentSwipeElement.querySelector('.swipe-indicator');
      if (!swipeIndicator) {
        swipeIndicator = document.createElement('div');
        swipeIndicator.className = 'swipe-indicator';
        swipeIndicator.innerHTML = '<i class="fas fa-reply"></i> Reply';
        currentSwipeElement.appendChild(swipeIndicator);
      }
      
      swipeIndicator.style.opacity = Math.min(swipeDistance / 80, 1);
    }
  });
  
  messagesContainer.addEventListener('mouseup', (e) => {
    if (!currentSwipeElement) return;
    
    const deltaX = touchStartX - e.clientX;
    
    const swipeIndicator = currentSwipeElement.querySelector('.swipe-indicator');
    if (swipeIndicator) {
      swipeIndicator.remove();
    }
    
    if (isSwiping && deltaX > 60) {
      const messageId = currentSwipeElement.id.replace('message-', '');
      const message = allMessages.find(m => m.id === messageId);
      if (message) {
        setReplyTo(message);
      }
    }
    
    currentSwipeElement.classList.remove('swiping');
    currentSwipeElement.style.transform = '';
    currentSwipeElement = null;
    isSwiping = false;
  });
  
  // Also allow right-click context menu for reply on desktop
  messagesContainer.addEventListener('contextmenu', (e) => {
    const messageElement = e.target.closest('.message');
    if (messageElement) {
      e.preventDefault();
      const messageId = messageElement.id.replace('message-', '');
      const message = allMessages.find(m => m.id === messageId);
      if (message) {
        setReplyTo(message);
      }
      return false;
    }
  });
}

// Set reply to a message
function setReplyTo(message) {
  currentReplyTo = message.id;
  replyToMessage = message;
  
  // Update preview
  replyPreviewUser.textContent = message.userId === currentUser.uid ? 'You' : 
    (message.isAdmin ? 'Admin' : 'User ' + message.userId.substring(0, 6));
  
  let previewText = message.text || '';
  if (message.isVoice) {
    previewText = 'ðŸŽ¤ Voice message';
  } else if (message.fileUrl) {
    if (message.fileType && message.fileType.startsWith('image/')) {
      previewText = 'ðŸ–¼ï¸ Image';
    } else if (message.fileType && message.fileType.startsWith('video/')) {
      previewText = 'ðŸŽ¬ Video';
    } else if (message.fileType && message.fileType.startsWith('audio/')) {
      previewText = 'ðŸŽµ Audio';
    } else {
      previewText = 'ðŸ“Ž File';
    }
  }
  
  replyPreviewText.textContent = previewText.length > 50 ? 
    previewText.substring(0, 50) + '...' : previewText;
  
  replyPreview.classList.add('active');
  messageInput.focus();
  
  showNotification('Replying to message');
}

// Clear reply
function clearReply() {
  currentReplyTo = null;
  replyToMessage = null;
  replyPreview.classList.remove('active');
}

// Set up image modal event listeners
function setupImageModalListeners() {
  imageModalClose.addEventListener('click', () => {
    imageModal.classList.remove('active');
  });
  
  imageModal.addEventListener('click', (e) => {
    if (e.target === imageModal) {
      imageModal.classList.remove('active');
    }
  });
}

// Initialize audio recording
function initAudioRecording() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    showNotification('Audio recording is not supported in your browser', 'error');
    toggleButton.disabled = true;
    return;
  }
  
  // Test microphone access
  navigator.mediaDevices.getUserMedia({ audio: true })
    .then(stream => {
      stream.getTracks().forEach(track => track.stop());
      console.log('Microphone access granted');
    })
    .catch(error => {
      console.error('Microphone access denied:', error);
      showNotification('Please allow microphone access to record voice messages', 'error');
      toggleButton.disabled = true;
    });
}

// Set up real-time listeners with proper error handling
function setupRealTimeListeners() {
  console.log('Setting up real-time listeners...');
  
  // Listen for new messages with error handling
  messagesListener = db.collection('messages')
    .where('deleted', '==', false)
    .orderBy('timestamp', 'asc')
    .limit(100)
    .onSnapshot(snapshot => {
      console.log('Messages snapshot received:', snapshot.size, 'messages');
      
      // Clear existing messages except welcome message
      const welcomeMsg = document.querySelector('.welcome-message');
      messagesContainer.innerHTML = '';
      if (welcomeMsg) {
        messagesContainer.appendChild(welcomeMsg);
      }

      // Reset allMessages array
      allMessages = [];

      // Add all messages
      snapshot.forEach(doc => {
        try {
          const message = {
            id: doc.id,
            ...doc.data()
          };
          allMessages.push(message);
          addMessageToChat(message);
        } catch (error) {
          console.error('Error processing message:', error);
        }
      });

      // Scroll to bottom
      setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }, 100);

    }, error => {
      console.error('Error listening to messages:', error);
      showNotification('Error loading messages. Please refresh the page.', 'error');
      
      // Try to reconnect after 5 seconds
      setTimeout(() => {
        if (messagesListener) {
          messagesListener(); // Unsubscribe old listener
        }
        setupRealTimeListeners();
      }, 5000);
    });

  // Update online count periodically
  updateOnlineCount();
  onlineInterval = setInterval(updateOnlineCount, 10000);
}

// Update online count using serverless function
async function updateOnlineCount() {
  try {
    const response = await fetch('/.netlify/functions/online-count1');
    if (response.ok) {
      const result = await response.json();
      onlineCount.textContent = `${result.count} online`;
    }
  } catch (error) {
    console.error('Error getting online count:', error);
  }
}

// Set up user presence system with proper cleanup
function setupUserPresence() {
  if (!currentUser) return;
  
  console.log('Setting up user presence for:', currentUser.uid);
  
  // Create a reference to this user's presence data
  userPresenceRef = db.collection('onlineUsers').doc(currentUser.uid);
  
  // Set initial user presence data
  userPresenceRef.set({
    userId: currentUser.uid,
    lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
    userAgent: navigator.userAgent,
    status: 'online'
  }).then(() => {
    isUserOnline = true;
    console.log('User marked as online');
  }).catch(error => {
    console.error('Error adding to online users:', error);
  });

  // Update last seen periodically
  const presenceInterval = setInterval(() => {
    if (currentUser && isUserOnline) {
      userPresenceRef.update({
        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
      }).catch(error => {
        console.error('Error updating online status:', error);
      });
    }
  }, 30000);

  // Set up beforeunload handler to mark user as offline
  window.addEventListener('beforeunload', () => {
    console.log('Cleaning up before unload...');
    cleanupBeforeUnload();
  });

  // Also handle page visibility changes
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden' && currentUser && isUserOnline) {
      setUserOffline();
    }
  });
}

// Cleanup function for beforeunload
function cleanupBeforeUnload() {
  // Clean up reactions listeners
  cleanupReactionsListeners();
  
  // Set user offline
  setUserOffline();
  
  // Clear intervals
  if (onlineInterval) {
    clearInterval(onlineInterval);
  }
  
  // Unsubscribe from listeners
  if (messagesListener) {
    messagesListener();
  }
}

// Set user offline
async function setUserOffline() {
  if (currentUser && isUserOnline) {
    isUserOnline = false;
    
    try {
      const response = await fetch('/.netlify/functions/set-user-offline1', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ userId: currentUser.uid }),
        keepalive: true // Important for beforeunload
      });
      
      if (!response.ok) {
        console.error('Failed to set user offline via function');
        // Fallback: try direct Firestore update
        if (userPresenceRef) {
          await userPresenceRef.delete().catch(e => console.error('Direct delete failed:', e));
        }
      }
    } catch (error) {
      console.error('Error setting user offline:', error);
      // Final fallback
      if (userPresenceRef) {
        userPresenceRef.delete().catch(e => console.error('Final delete failed:', e));
      }
    }
  }
}

// Set up event listeners
function setupEventListeners() {
  console.log('Setting up event listeners...');
  
  // Menu toggle
  menuToggle.addEventListener('click', (e) => {
    e.stopPropagation();
    dropdownMenu.classList.toggle('show');
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (!menuToggle.contains(e.target) && !dropdownMenu.contains(e.target)) {
      dropdownMenu.classList.remove('show');
    }
  });

  // Search button
  searchBtn.addEventListener('click', () => {
    searchContainer.classList.add('active');
    searchInput.focus();
  });

  // Close search
  closeSearch.addEventListener('click', () => {
    searchContainer.classList.remove('active');
    searchResults.innerHTML = '';
  });

  // Search input
  searchInput.addEventListener('input', (e) => {
    const searchTerm = e.target.value.trim().toLowerCase();
    if (searchTerm.length > 0) {
      performSearch(searchTerm);
    } else {
      searchResults.innerHTML = '';
    }
  });

  // GIF/Sticker button
  gifStickerBtn.addEventListener('click', () => {
    showGifStickerPicker();
  });

  // Toggle button functionality
  toggleButton.addEventListener('click', handleToggleButtonClick);

  // Send message on Enter key
  messageInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  // Update button based on input
  messageInput.addEventListener('input', updateButtonMode);

  // Cancel recording button
  cancelRecording.addEventListener('click', handleCancelRecording);

  // Edit mode cancel
  editCancel.addEventListener('click', cancelEdit);

  // Reply preview cancel
  replyPreviewCancel.addEventListener('click', clearReply);

  // About and Privacy links
  document.getElementById('about-link').addEventListener('click', (e) => {
    e.preventDefault();
    dropdownMenu.classList.remove('show');
    showNotification('About Us: This is a community chat system designed for real-time communication.');
  });

  document.getElementById('privacy-link').addEventListener('click', (e) => {
    e.preventDefault();
    dropdownMenu.classList.remove('show');
    showNotification('Privacy Policy: We value your privacy. Your messages are secure and we do not share your data with third parties.');
  });
  
  console.log('Event listeners setup complete');
}

// Handle toggle button click based on current mode
function handleToggleButtonClick() {
  if (messageInput.value.trim()) {
    // If there's text, send the message
    sendMessage();
  } else {
    // If no text, toggle voice recording
    toggleVoiceRecording();
  }
}

// Update button mode based on input
function updateButtonMode() {
  const hasText = messageInput.value.trim().length > 0;
  
  if (hasText) {
    // Change to send mode
    toggleButton.classList.add('send-mode');
    toggleButton.innerHTML = '<i class="fas fa-paper-plane"></i>';
  } else {
    // Change to voice mode
    toggleButton.classList.remove('send-mode');
    toggleButton.innerHTML = '<i class="fas fa-microphone"></i>';
  }
}

// Perform search by user ID or admin messages
function performSearch(searchTerm) {
  const searchTermLower = searchTerm.toLowerCase();
  
  const filteredMessages = allMessages.filter(message => {
    // Search for admin messages when user types "admin"
    if (searchTermLower === 'admin') {
      return message.isAdmin === true;
    }
    
    // Otherwise search by user ID
    return message.userId.toLowerCase().includes(searchTermLower);
  });
  
  searchResults.innerHTML = '';
  
  if (filteredMessages.length === 0) {
    searchResults.innerHTML = '<div class="welcome-message">No messages found</div>';
    return;
  }
  
  filteredMessages.forEach(message => {
    const messageEl = createMessageElement(message);
    searchResults.appendChild(messageEl);
  });
}

// Create message element for search results
function createMessageElement(message) {
  const messageEl = document.createElement('div');
  messageEl.classList.add('message');
  messageEl.classList.add(message.userId === currentUser.uid ? 'own' : 'other');

  // Format timestamp
  let timeText = 'Just now';
  if (message.timestamp) {
    const timestamp = message.timestamp.toDate();
    timeText = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }

  // Create message content based on type
  let messageContentHTML = '';
  if (message.isVoice && (message.audioUrl || message.fileUrl)) {
    const voiceUrl = message.audioUrl || message.fileUrl;
    messageContentHTML = `
      <div class="voice-message-indicator">
        <i class="fas fa-microphone"></i>
        <span>Voice message</span>
        <audio controls style="margin-left: 10px;">
          <source src="${voiceUrl}" type="${message.fileType || 'audio/webm'}">
          Your browser does not support the audio element.
        </audio>
      </div>
    `;
  } else if (message.fileUrl) {
    // Determine file type and display appropriately
    if (isImageFile(message.fileUrl, message.fileType)) {
      messageContentHTML = `
        <div class="file-preview-container">
          <img src="${message.fileUrl}" alt="Image" class="image-preview" onclick="openImageModal('${message.fileUrl}')">
        </div>
      `;
    } else if (isVideoFile(message.fileUrl, message.fileType)) {
      messageContentHTML = `
        <div class="file-preview-container">
          <video controls class="video-player">
            <source src="${message.fileUrl}" type="${message.fileType || 'video/mp4'}">
            Your browser does not support the video tag.
          </video>
        </div>
      `;
    } else if (isAudioFile(message.fileUrl, message.fileType)) {
      messageContentHTML = `
        <div class="file-preview-container">
          <audio controls class="audio-player">
            <source src="${message.fileUrl}" type="${message.fileType || 'audio/mpeg'}">
            Your browser does not support the audio element.
          </audio>
        </div>
      `;
    } else {
      messageContentHTML = createDocumentFileElement(message.fileUrl, message.fileName);
    }
  } else {
    messageContentHTML = message.text;
  }

  // Add reply indicator if message is a reply
  let replyHTML = '';
  if (message.replyTo) {
    const repliedMessage = allMessages.find(m => m.id === message.replyTo);
    if (repliedMessage) {
      let repliedText = repliedMessage.text || '';
      if (repliedMessage.isVoice) {
        repliedText = 'Voice message';
      } else if (repliedMessage.fileUrl) {
        repliedText = 'Media file';
      }
      replyHTML = `
        <div class="message-reply" onclick="scrollToMessage('${message.replyTo}')">
          <div class="reply-indicator">
            <i class="fas fa-reply"></i>
            Replying to ${repliedMessage.userId === currentUser.uid ? 'yourself' : 
              (repliedMessage.isAdmin ? 'Admin' : 'User ' + repliedMessage.userId.substring(0, 6))}
          </div>
          <div class="reply-content ${!repliedMessage.text ? 'media-reply' : ''}">
            ${repliedText.length > 100 ? repliedText.substring(0, 100) + '...' : repliedText}
          </div>
        </div>
      `;
    }
  }

  messageEl.innerHTML = `
    <div class="message-info">
      <div class="message-user">${message.userId === currentUser.uid ? 'You' : (message.isAdmin ? 'Admin' : 'User ' + message.userId.substring(0, 6))}</div>
      <div class="message-time">${timeText}</div>
    </div>
    ${replyHTML}
    <div class="message-content">
      ${messageContentHTML}
    </div>
  `;

  return messageEl;
}

// Scroll to a specific message
function scrollToMessage(messageId) {
  const messageElement = document.getElementById(`message-${messageId}`);
  if (messageElement) {
    messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    // Add highlight effect
    messageElement.style.backgroundColor = 'rgba(74, 108, 250, 0.1)';
    setTimeout(() => {
      messageElement.style.backgroundColor = '';
    }, 2000);
  }
}

// Create document file element WITHOUT download button
function createDocumentFileElement(fileUrl, fileName) {
  const fileExtension = getFileExtension(fileName);
  const iconClass = getFileIconClass(fileExtension);
  
  // Ensure filename is never null
  const safeFileName = fileName || 'file';
  
  // Create a clickable document element that downloads on click
  return `
    <a href="${fileUrl}" download="${safeFileName}" class="document-file" style="text-decoration: none; color: inherit;">
      <div class="document-icon">
        <i class="${iconClass}"></i>
      </div>
      <div class="document-info">
        <div class="document-name">${safeFileName}</div>
        <div class="document-size">${fileExtension.toUpperCase()} file - Click to download</div>
      </div>
    </a>
  `;
}

// Get file extension from filename
function getFileExtension(filename) {
  if (!filename) return 'file';
  const parts = filename.split('.');
  return parts.length > 1 ? parts.pop().toLowerCase() : 'file';
}

// Get appropriate icon class for file type
function getFileIconClass(extension) {
  const iconMap = {
    'pdf': 'fas fa-file-pdf',
    'doc': 'fas fa-file-word',
    'docx': 'fas fa-file-word',
    'txt': 'fas fa-file-alt',
    'csv': 'fas fa-file-csv',
    'xls': 'fas fa-file-excel',
    'xlsx': 'fas fa-file-excel',
    'ppt': 'fas fa-file-powerpoint',
    'pptx': 'fas fa-file-powerpoint',
    'zip': 'fas fa-file-archive',
    'rar': 'fas fa-file-archive',
    '7z': 'fas fa-file-archive'
  };
  
  return iconMap[extension] || 'fas fa-file';
}

// Check if file is an image
function isImageFile(fileUrl, fileType) {
  if (fileType === 'image') return true;
  if (fileType && fileType.startsWith('image/')) return true;
  
  const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg'];
  const lowerUrl = (fileUrl || '').toLowerCase();
  return imageExtensions.some(ext => lowerUrl.includes(ext));
}

// Check if file is a video
function isVideoFile(fileUrl, fileType) {
  if (fileType === 'video') return true;
  if (fileType && fileType.startsWith('video/')) return true;
  
  const videoExtensions = ['.mp4', '.webm', '.ogg', '.mov', '.avi', '.mkv'];
  const lowerUrl = (fileUrl || '').toLowerCase();
  return videoExtensions.some(ext => lowerUrl.includes(ext));
}

// Check if file is an audio file
function isAudioFile(fileUrl, fileType) {
  if (fileType === 'audio') return true;
  if (fileType && fileType.startsWith('audio/')) return true;
  
  const audioExtensions = ['.mp3', '.wav', '.ogg', '.m4a', '.aac', '.flac', '.webm'];
  const lowerUrl = (fileUrl || '').toLowerCase();
  return audioExtensions.some(ext => lowerUrl.includes(ext));
}

// Open image in modal for fullscreen view
function openImageModal(imageUrl) {
  imageModalImg.src = imageUrl;
  imageModal.classList.add('active');
}

// Toggle voice recording
function toggleVoiceRecording() {
  if (isRecording) {
    stopVoiceRecording();
  } else {
    startVoiceRecording();
  }
}

// Start voice recording
async function startVoiceRecording() {
  try {
    isCancelingRecording = false;
    
    // Request microphone access
    mediaStream = await navigator.mediaDevices.getUserMedia({ 
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        sampleRate: 44100,
        channelCount: 1
      } 
    });
    
    // Initialize media recorder with options for longer recordings
    const options = { 
      mimeType: 'audio/webm;codecs=opus',
      audioBitsPerSecond: 128000 // Higher quality for longer recordings
    };
    
    mediaRecorder = new MediaRecorder(mediaStream, options);
    audioChunks = [];

    mediaRecorder.ondataavailable = (event) => {
      if (!isCancelingRecording) {
        audioChunks.push(event.data);
      }
    };

    mediaRecorder.onstop = async () => {
      // Only send if not canceling
      if (!isCancelingRecording && audioChunks.length > 0) {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        await sendAudioMessage(audioBlob);
      }
      
      // Clean up media stream
      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      }
    };

    mediaRecorder.start(1000); // Capture data in 1-second chunks
    isRecording = true;
    voiceRecording.classList.add('active');
    recordingText.textContent = "Recording...";
    toggleButton.innerHTML = '<i class="fas fa-stop"></i>';
    toggleButton.classList.add('recording');
    
    // Start recording timer
    recordingSeconds = 0;
    recordingInterval = setInterval(() => {
      recordingSeconds++;
      const minutes = Math.floor(recordingSeconds / 60);
      const seconds = recordingSeconds % 60;
      recordingTimer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      // Auto-stop after 2 minutes (120 seconds)
      if (recordingSeconds >= 120) {
        stopVoiceRecording();
      }
    }, 1000);
  } catch (error) {
    console.error('Error accessing microphone:', error);
    showNotification('Error accessing microphone: ' + error.message, 'error');
  }
}

// Stop voice recording
function stopVoiceRecording() {
  if (mediaRecorder && isRecording) {
    mediaRecorder.stop();
    isRecording = false;
    voiceRecording.classList.remove('active');
    toggleButton.classList.remove('recording');
    updateButtonMode(); // Reset button to appropriate mode
    
    // Clear recording timer
    if (recordingInterval) {
      clearInterval(recordingInterval);
      recordingInterval = null;
    }
    recordingTimer.textContent = "0:00";
  }
}

// Handle cancel recording
function handleCancelRecording() {
  // Immediately update UI for better responsiveness
  voiceRecording.classList.remove('active');
  toggleButton.classList.remove('recording');
  updateButtonMode(); // Reset button to appropriate mode
  recordingTimer.textContent = "0:00";
  
  // Clear recording timer
  if (recordingInterval) {
    clearInterval(recordingInterval);
    recordingInterval = null;
  }
  
  // Set cancel flag
  isCancelingRecording = true;
  
  // Stop media recorder if it exists
  if (mediaRecorder && isRecording) {
    try {
      mediaRecorder.stop();
    } catch (e) {
      console.log('MediaRecorder already stopped');
    }
    isRecording = false;
  }
  
  // Stop media stream if it exists
  if (mediaStream) {
    mediaStream.getTracks().forEach(track => track.stop());
    mediaStream = null;
  }
  
  // Clear audio chunks
  audioChunks = [];
  
  showNotification('Recording cancelled');
}

// Send audio message using serverless function
async function sendAudioMessage(audioBlob) {
  try {
    // Show uploading notification
    showNotification('Uploading audio message...');
    
    // Create a FormData object to send the file
    const formData = new FormData();
    formData.append('audio', audioBlob, `voice_${Date.now()}.webm`);
    formData.append('userId', currentUser.uid);
    
    // Send audio message using serverless function
    const response = await fetch('/.netlify/functions/send-voice-message', {
      method: 'POST',
      body: formData
    });
    
    const result = await response.json();
    
    if (!response.ok) {
      throw new Error(result.error);
    }
    
    showNotification('Audio message sent successfully');
  } catch (error) {
    console.error('Error sending audio message:', error);
    showNotification('Error sending audio message: ' + error.message, 'error');
  }
}

// Send a message using serverless function
async function sendMessage() {
  const text = messageInput.value.trim();

  if (text || editMessageId) {
    try {
      if (editMessageId) {
        // Edit existing message using serverless function
        await editExistingMessage(editMessageId, text);
        editMessageId = null;
        editMode.classList.remove('active');
      } else {
        // Create new message using serverless function
        const response = await fetch('/.netlify/functions/messages-get1', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            message: text,
            userId: currentUser.uid,
            replyTo: currentReplyTo || null
          }),
        });

        const result = await response.json();
        
        if (!response.ok) {
          throw new Error(result.error);
        }
      }

      messageInput.value = '';
      updateButtonMode(); // Update button after clearing input
      clearReply(); // Clear reply after sending
    } catch (error) {
      console.error('Error sending message:', error);
      showNotification('Error: ' + error.message, 'error');
    }
  }
}

// Edit existing message using serverless function
async function editExistingMessage(messageId, newText) {
  try {
    const response = await fetch('/.netlify/functions/update-message1', {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        messageId: messageId,
        newText: newText,
        userId: currentUser.uid
      }),
    });

    const result = await response.json();
    
    if (!response.ok) {
      throw new Error(result.error);
    }
    
    showNotification('Message updated successfully');
  } catch (error) {
    console.error('Error editing message:', error);
    showNotification('Error: ' + error.message, 'error');
    throw error;
  }
}

// Initialize emoji picker - FIXED VERSION
function initEmojiPicker() {
  emojiPicker = document.getElementById('emoji-picker');
  const emojiPickerClose = document.getElementById('emoji-picker-close');
  const longPressOverlay = document.getElementById('long-press-overlay');
  
  // Define emoji categories
  emojiCategories = {
    'frequently-used': {
      name: 'Frequent',
      emojis: ['ðŸ‘', 'â¤ï¸', 'ðŸ˜‚', 'ðŸ˜®', 'ðŸ˜¢', 'ðŸ‘', 'ðŸ”¥', 'ðŸŽ‰', 'ðŸ¤”', 'ðŸ‘Ž']
    },
    'smileys': {
      name: 'Smileys',
      emojis: ['ðŸ˜€', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜†', 'ðŸ˜…', 'ðŸ˜‚', 'ðŸ¤£', 'ðŸ˜Š', 'ðŸ˜‡', 
               'ðŸ™‚', 'ðŸ™ƒ', 'ðŸ˜‰', 'ðŸ˜Œ', 'ðŸ˜', 'ðŸ¥°', 'ðŸ˜˜', 'ðŸ˜—', 'ðŸ˜™', 'ðŸ˜š',
               'ðŸ˜‹', 'ðŸ˜›', 'ðŸ˜', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ¤¨', 'ðŸ§', 'ðŸ¤“', 'ðŸ˜Ž', 'ðŸ¤©',
               'ðŸ¥³', 'ðŸ˜', 'ðŸ˜’', 'ðŸ˜ž', 'ðŸ˜”', 'ðŸ˜Ÿ', 'ðŸ˜•', 'ðŸ™', 'â˜¹ï¸', 'ðŸ˜£',
               'ðŸ¤”', 'ðŸ™„', 'ðŸ˜­', 'ðŸ¤—', 'ðŸ˜¡', 'ðŸ¤¥', 'ðŸ¥¹', 'ðŸ« ', 'ðŸ¥º', 'ðŸ¤¤',
               'ðŸ«¥', 'ðŸ˜¶', 'ðŸ«¡', 'ðŸ¤¬', 'ðŸ˜²', 'ðŸ˜¯', 'ðŸ˜®', 'ðŸ˜¦', 'ðŸ˜§', 'ðŸ¥µ', 
               'ðŸ¤§', 'ðŸ¤’', 'ðŸ¤•', 'ðŸ˜·', 'ðŸ¤¥', 'ðŸ¤ ', 'ðŸ¤‘', 'ðŸ¥¸', 'ðŸ˜µ', 'ðŸ˜©',   
               'ðŸ«£', 'ðŸ˜±', 'ðŸ¥±', 'ðŸ¤­', 'ðŸ«¢', 'ðŸ¤«', 'ðŸ˜«', 'ðŸ˜ª', 'ðŸ¤¡', 'ðŸ¥¸',             
               'ðŸŽƒ', 'ðŸ’©', 'ðŸŒš', 'ðŸŒ', 'ðŸ˜º', 'ðŸ˜¸', 'ðŸ˜¹', 'ðŸ™Š', 'ðŸ™‰', 'ðŸ™ˆ', 
               'ðŸŒ›', 'ðŸŒœ', 'ðŸŒž', 'ðŸ˜¾', 'ðŸ˜»', 'ðŸ˜¼', 'ðŸ˜½', 'ðŸ™€', 'ðŸ˜¿', 'ðŸ˜ˆ',  
               'ðŸ‘¿', 'ðŸ‘»', 'ðŸ’€', 'â˜ ï¸', 'ðŸ‘¹', 'ðŸ‘º']
    },
    'people': {
      name: 'People',
      emojis: ['ðŸ™‡', 'ðŸ™‹', 'ðŸ’',  'ðŸ™†','ðŸ™…', 'ðŸ¤·', 'ðŸ¤¦', 'ðŸ™', 'ðŸ™Ž', 'ðŸ§',
               'ðŸ’†', 'ðŸ’‡', 'ðŸ§–',  'ðŸ›€','ðŸ›Œ', 'ðŸ§˜', 'ðŸ§', 'ðŸ¤¸', 'ðŸ§Ž', 'ðŸ§‘', 
               'ðŸ¤½', 'ðŸ§œ', 'ðŸ§š',  'ðŸ§ž','ðŸ§', 'ðŸ§™', 'ðŸ§›', 'ðŸ§Ÿ', 'ðŸ§Œ', 'ðŸ¦¸',
               'ðŸ¦¹', 'ðŸ¥·', 'ðŸ§‘',  'ðŸ’‚','ðŸ«…', 'ðŸ¤µ', 'ðŸ‘°', 'ðŸ‘¶', 'ðŸ§’', 'ðŸ§‘',                        
               'ðŸ‘‹', 'ðŸ¤š', 'ðŸ–ï¸', 'âœ‹', 'ðŸ––', 'ðŸ‘Œ', 'ðŸ¤Œ', 'ðŸ¤', 'âœŒï¸', 'ðŸ¤ž',
               'ðŸ¤Ÿ', 'ðŸ¤˜', 'ðŸ¤™',  'ðŸ‘ˆ','ðŸ‘‰', 'ðŸ‘†', 'ðŸ–•', 'ðŸ‘‡', 'â˜ï¸', 'ðŸ‘',
               'ðŸ‘Ž', 'âœŠ',  'ðŸ‘Š',  'ðŸ¤›','ðŸ¤œ', 'ðŸ‘', 'ðŸ™Œ', 'ðŸ‘', 'ðŸ¤²', 'ðŸ¤',
               'ðŸ’ª', 'ðŸ«¶', 'ðŸ«³',  'ðŸ«´','ðŸ«±', 'ðŸ«²', 'ðŸ«°', 'ðŸ¤™', 'ðŸ«µ', 'âœï¸',
               'ðŸ¤³', 'ðŸ’…', 'ðŸ™']
    },
    'objects': {
      name: 'Objects',
      emojis: ['ðŸ’¯', 'âœ¨', 'ðŸŒŸ', 'ðŸ’«', 'ðŸŽŠ', 'ðŸŽ‰', 'ðŸŽˆ', 'ðŸŽ', 'ðŸ†', 'ðŸŽ—ï¸',
               'ðŸ…', 'ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰', 'âš½', 'ðŸ€', 'ðŸˆ', 'âš¾', 'ðŸ¥Ž', 'ðŸŽ¾',
               'ðŸ', 'ðŸ‰', 'ðŸ¥', 'ðŸŽ±', 'ðŸª€', 'ðŸ“', 'ðŸ¸', 'ðŸ’', 'ðŸ‘', 'ðŸ¥']
    },
    'symbols': {
      name: 'Symbols',
      emojis: ['â¤ï¸', 'ðŸ§¡', 'ðŸ’›', 'ðŸ’š', 'ðŸ’™', 'ðŸ’œ', 'ðŸ–¤', 'ðŸ¤', 'ðŸ¤Ž', 'ðŸ’”',
               'ðŸ‘…', 'ðŸ«¦', 'ðŸ‘„', 'ðŸ‘', 
               'â¤ï¸â€ðŸ”¥', 'â¤ï¸â€ðŸ©¹', 'ðŸ’•', 'ðŸ’ž', 'ðŸ’“', 'ðŸ’—', 'ðŸ’–', 'ðŸ’˜', 'ðŸ’', 'ðŸ’Ÿ',
               'â˜®ï¸', 'âœï¸', 'â˜ªï¸', 'ðŸ•‰', 'â˜¸ï¸', 'âœ¡ï¸', 'ðŸ”¯', 'ðŸ•Ž', 'â˜¯ï¸', 'â˜¦ï¸']
    }
  };
  
  // Render emoji categories
  const categoriesContainer = document.getElementById('emoji-categories');
  const emojiGrid = document.getElementById('emoji-grid');
  
  Object.keys(emojiCategories).forEach(categoryId => {
    const category = emojiCategories[categoryId];
    const categoryBtn = document.createElement('button');
    categoryBtn.className = 'emoji-category-btn';
    categoryBtn.textContent = category.emojis[0]; // Use first emoji as icon
    categoryBtn.title = category.name;
    categoryBtn.dataset.category = categoryId;
    
    categoryBtn.addEventListener('click', () => {
      // Update active category
      document.querySelectorAll('.emoji-category-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      categoryBtn.classList.add('active');
      
      // Render emojis for this category
      renderEmojis(categoryId);
    });
    
    categoriesContainer.appendChild(categoryBtn);
  });
  
  // Set first category as active
  const firstCategoryBtn = categoriesContainer.querySelector('.emoji-category-btn');
  if (firstCategoryBtn) {
    firstCategoryBtn.classList.add('active');
    renderEmojis(firstCategoryBtn.dataset.category);
  }
  
  // Close emoji picker
  emojiPickerClose.addEventListener('click', hideEmojiPicker);
  
  // Close when clicking outside
  document.addEventListener('click', (e) => {
    if (emojiPickerVisible && !emojiPicker.contains(e.target) && 
        !e.target.closest('.message-content') && 
        e.target !== longPressOverlay) {
      hideEmojiPicker();
    }
  });
  
  // Set up message long press detection - FIXED
  setupMessageLongPress();
}

// Render emojis for a category
function renderEmojis(categoryId) {
  const emojiGrid = document.getElementById('emoji-grid');
  const category = emojiCategories[categoryId];
  
  if (!category) return;
  
  emojiGrid.innerHTML = '';
  
  category.emojis.forEach(emoji => {
    const emojiBtn = document.createElement('button');
    emojiBtn.className = 'emoji-btn';
    emojiBtn.textContent = emoji;
    emojiBtn.title = `React with ${emoji}`;
    
    emojiBtn.addEventListener('click', () => {
      if (currentMessageForReaction && currentMessageElementForReaction) {
        handleEmojiReaction(currentMessageForReaction, emoji);
        hideEmojiPicker();
      }
    });
    
    emojiGrid.appendChild(emojiBtn);
  });
}

// Set up message long press detection - FIXED
function setupMessageLongPress() {
  const messagesContainer = document.getElementById('messages-container');
  const longPressOverlay = document.getElementById('long-press-overlay');
  
  // Mouse events for desktop
  messagesContainer.addEventListener('mousedown', (e) => {
    const messageElement = e.target.closest('.message');
    if (messageElement && !e.target.closest('.message-actions') && 
        !e.target.closest('.message-reactions') && !e.target.closest('.message-reply')) {
      const messageId = messageElement.id.replace('message-', '');
      if (messageId) {
        currentMessageForReaction = messageId;
        currentMessageElementForReaction = messageElement;
        longPressTimer = setTimeout(() => {
          showEmojiPickerForMessage(messageElement);
        }, 800); // 800ms for mouse long press
      }
    }
  });
  
  messagesContainer.addEventListener('mouseup', clearLongPressTimer);
  messagesContainer.addEventListener('mouseleave', clearLongPressTimer);
  
  // Touch events for mobile
  messagesContainer.addEventListener('touchstart', (e) => {
    const messageElement = e.target.closest('.message');
    if (messageElement && !e.target.closest('.message-actions') && 
        !e.target.closest('.message-reactions') && !e.target.closest('.message-reply')) {
      const messageId = messageElement.id.replace('message-', '');
      if (messageId) {
        currentMessageForReaction = messageId;
        currentMessageElementForReaction = messageElement;
        touchStartTime = Date.now();
        longPressTimer = setTimeout(() => {
          showEmojiPickerForMessage(messageElement);
        }, 600); // 600ms for touch long press
      }
    }
  });
  
  messagesContainer.addEventListener('touchend', clearLongPressTimer);
  messagesContainer.addEventListener('touchmove', clearLongPressTimer);
  
  // Prevent context menu on long press
  messagesContainer.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    const messageElement = e.target.closest('.message');
    if (messageElement) {
      const messageId = messageElement.id.replace('message-', '');
      if (messageId) {
        currentMessageForReaction = messageId;
        currentMessageElementForReaction = messageElement;
        showEmojiPickerForMessage(messageElement);
      }
    }
    return false;
  });
}

// Clear long press timer
function clearLongPressTimer() {
  if (longPressTimer) {
    clearTimeout(longPressTimer);
    longPressTimer = null;
  }
}

// Show emoji picker for message - FIXED POSITIONING
function showEmojiPickerForMessage(messageElement) {
  clearLongPressTimer();
  
  const emojiPicker = document.getElementById('emoji-picker');
  const longPressOverlay = document.getElementById('long-press-overlay');
  
  if (!messageElement || !currentMessageForReaction) return;
  
  // Get the position of the message element
  const rect = messageElement.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  
  // Calculate position above the message
  let left = rect.left + (rect.width / 2);
  let top = rect.top - 10;
  
  // If too close to top, show below
  if (top < 100) {
    top = rect.bottom + 10;
  }
  
  // Ensure picker stays within viewport
  const pickerWidth = 320;
  const pickerHeight = 400;
  
  // Adjust horizontal position
  if (left + pickerWidth / 2 > viewportWidth) {
    left = viewportWidth - pickerWidth / 2 - 10;
  }
  if (left - pickerWidth / 2 < 0) {
    left = pickerWidth / 2 + 10;
  }
  
  // Adjust vertical position (for the picker going off the bottom)
  if (top + pickerHeight > viewportHeight) {
    top = viewportHeight - pickerHeight - 10;
  }
  if (top < 10) {
    top = 10;
  }
  
  // Set position with transform centered horizontally
  emojiPicker.style.left = `${left}px`;
  emojiPicker.style.top = `${top}px`;
  emojiPicker.style.transform = `translateX(-50%)`;
  
  // Show picker
  emojiPicker.classList.add('active');
  longPressOverlay.classList.add('active');
  emojiPickerVisible = true;
  
  // Prevent body scroll
  document.body.style.overflow = 'hidden';
}

// Hide emoji picker
function hideEmojiPicker() {
  const emojiPicker = document.getElementById('emoji-picker');
  const longPressOverlay = document.getElementById('long-press-overlay');
  
  emojiPicker.classList.remove('active');
  longPressOverlay.classList.remove('active');
  emojiPickerVisible = false;
  currentMessageForReaction = null;
  currentMessageElementForReaction = null;
  
  // Restore body scroll
  document.body.style.overflow = '';
}

// Handle emoji reaction - FIXED
async function handleEmojiReaction(messageId, emoji) {
  if (!currentUser || !messageId || !emoji) return;
  
  try {
    // Send to server
    const response = await fetch('/.netlify/functions/add-reaction', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        messageId: messageId,
        userId: currentUser.uid,
        emoji: emoji,
        action: 'toggle' // Toggle reaction (add if not present, remove if present)
      }),
    });
    
    const result = await response.json();
    
    if (!response.ok) {
      throw new Error(result.error);
    }
    
    // Show brief feedback
    const messageElement = document.getElementById(`message-${messageId}`);
    if (messageElement) {
      const reactionFeedback = document.createElement('div');
      reactionFeedback.style.cssText = `
        position: absolute;
        bottom: -30px;
        left: 50%;
        transform: translateX(-50%);
        background: #4a6cfa;
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 12px;
        z-index: 100;
        animation: fadeOut 1s ease forwards;
      `;
      reactionFeedback.textContent = `${emoji} ${result.action === 'added' ? 'added' : 'removed'}`;
      messageElement.appendChild(reactionFeedback);
      
      setTimeout(() => {
        if (reactionFeedback.parentNode) {
          reactionFeedback.remove();
        }
      }, 1000);
    }
  } catch (error) {
    console.error('Error handling reaction:', error);
    showNotification('Error reacting to message: ' + error.message, 'error');
  }
}

// Set up reactions listener for a message
function setupReactionsListener(messageId) {
  // Remove existing listener if any
  if (reactionsListeners.has(messageId)) {
    reactionsListeners.get(messageId)();
    reactionsListeners.delete(messageId);
  }
  
  const messageRef = db.collection('messages').doc(messageId);
  
  // Listen for reactions
  const unsubscribe = messageRef.collection('reactions')
    .onSnapshot((snapshot) => {
      updateMessageReactions(messageId, snapshot);
    }, (error) => {
      console.error('Error listening to reactions:', error);
    });
  
  reactionsListeners.set(messageId, unsubscribe);
}

// Update message reactions UI - FIXED
function updateMessageReactions(messageId, snapshot) {
  const messageElement = document.getElementById(`message-${messageId}`);
  if (!messageElement) return;
  
  let reactionsContainer = messageElement.querySelector('.message-reactions');
  
  if (!reactionsContainer) {
    reactionsContainer = document.createElement('div');
    reactionsContainer.className = 'message-reactions';
    
    const messageContent = messageElement.querySelector('.message-content');
    if (messageContent) {
      messageContent.classList.add('has-reactions');
      // Insert reactions container after message content
      messageContent.parentNode.insertBefore(reactionsContainer, messageContent.nextSibling);
    }
  }
  
  // Clear existing reactions
  reactionsContainer.innerHTML = '';
  
  // Group reactions by emoji
  const reactionsByEmoji = {};
  const userReactions = {};
  
  snapshot.forEach(doc => {
    const reaction = doc.data();
    const userId = reaction.userId;
    const emoji = reaction.emoji;
    
    if (!reactionsByEmoji[emoji]) {
      reactionsByEmoji[emoji] = {
        count: 0,
        users: []
      };
    }
    
    reactionsByEmoji[emoji].count++;
    reactionsByEmoji[emoji].users.push(userId);
    
    // Track user's own reactions
    if (currentUser && userId === currentUser.uid) {
      userReactions[emoji] = true;
    }
  });
  
  // Create reaction items
  Object.keys(reactionsByEmoji).forEach(emoji => {
    const reactionData = reactionsByEmoji[emoji];
    const isOwnReaction = userReactions[emoji] || false;
    
    const reactionItem = document.createElement('div');
    reactionItem.className = `reaction-item ${isOwnReaction ? 'own-reaction' : ''}`;
    reactionItem.dataset.emoji = emoji;
    reactionItem.title = `${reactionData.count} reaction${reactionData.count > 1 ? 's' : ''}`;
    
    reactionItem.innerHTML = `
      <span class="reaction-emoji">${emoji}</span>
      <span class="reaction-count">${reactionData.count}</span>
    `;
    
    // Click to toggle reaction
    reactionItem.addEventListener('click', (e) => {
      e.stopPropagation();
      if (currentUser) {
        handleEmojiReaction(messageId, emoji);
      }
    });
    
    reactionsContainer.appendChild(reactionItem);
  });
  
  // Show reactions container only if there are reactions
  if (Object.keys(reactionsByEmoji).length > 0) {
    reactionsContainer.style.display = 'flex';
  } else {
    reactionsContainer.style.display = 'none';
  }
}

// Clean up reactions listeners
function cleanupReactionsListeners() {
  reactionsListeners.forEach((unsubscribe, messageId) => {
    unsubscribe();
  });
  reactionsListeners.clear();
}

// Add message to chat UI
function addMessageToChat(message) {
  const welcomeMsg = document.querySelector('.welcome-message');
  if (welcomeMsg) {
    welcomeMsg.remove();
  }

  // Check if message already exists
  if (document.getElementById(`message-${message.id}`)) {
    return;
  }

  const messageEl = document.createElement('div');
  messageEl.classList.add('message');
  messageEl.classList.add(message.userId === currentUser.uid ? 'own' : 'other');
  messageEl.id = `message-${message.id}`;

  // Format timestamp
  let timeText = 'Just now';
  if (message.timestamp) {
    const timestamp = message.timestamp.toDate();
    timeText = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    // If edited, show edit time
    if (message.edited) {
      timeText += ' (edited)';
    }
  }
  
  // Build content based on type
  let messageContentHTML = '';
  
  if (message.isVoice && (message.audioUrl || message.fileUrl)) {
    // ðŸŽ¤ Voice message (support old audioUrl + new fileUrl)
    const voiceUrl = message.audioUrl || message.fileUrl;
    messageContentHTML = `
      <div class="voice-message-indicator">
        <i class="fas fa-microphone"></i>
        <span>Voice message</span>
        <audio controls style="margin-left: 10px;">
          <source src="${voiceUrl}" type="${message.fileType || 'audio/webm'}">
          Your browser does not support the audio element.
        </audio>
      </div>
    `;
  } else if (message.fileUrl) {
    // ðŸ“‚ File messages (images, videos, audio, documents, GIFs, stickers)
    if (isImageFile(message.fileUrl, message.fileType)) {
      // Check if it's a GIF
      const isGif = message.fileUrl.toLowerCase().includes('.gif') || 
                   (message.fileType && message.fileType === 'image/gif');
      // Check if it's likely a sticker (small image or PNG)
      const isSticker = message.fileType === 'image/png' || 
                       (message.fileName && message.fileName.includes('sticker'));
      
      if (isGif) {
        messageContentHTML = `
          <div class="file-preview-container">
            <img src="${message.fileUrl}" alt="GIF" class="image-preview" onclick="openImageModal('${message.fileUrl}')">
          </div>
        `;
      } else if (isSticker) {
        messageContentHTML = `
          <div class="file-preview-container">
            <img src="${message.fileUrl}" alt="Sticker" class="image-preview" style="max-height: 150px;">
          </div>
        `;
      } else {
        // Regular image
        messageContentHTML = `
          <div class="file-preview-container">
            <img src="${message.fileUrl}" alt="Image" class="image-preview" onclick="openImageModal('${message.fileUrl}')">
          </div>
        `;
      }
    } else if (isVideoFile(message.fileUrl, message.fileType)) {
      // Video player inside chat
      messageContentHTML = `
        <div class="file-preview-container">
          <video controls class="video-player">
            <source src="${message.fileUrl}" type="${message.fileType || 'video/mp4'}">
            Your browser does not support the video tag.
          </video>
        </div>
      `;
    } else if (isAudioFile(message.fileUrl, message.fileType)) {
      // Audio player inside chat
      messageContentHTML = `
        <div class="file-preview-container">
          <audio controls class="audio-player">
            <source src="${message.fileUrl}" type="${message.fileType || 'audio/mpeg'}">
            Your browser does not support the audio element.
          </audio>
        </div>
      `;
    } else {
      // Document files WITHOUT download button - entire element is clickable
      const fileName = message.fileName || 'file';
      messageContentHTML = createDocumentFileElement(message.fileUrl, fileName);
    }
  } else {
    // ðŸ“ Plain text fallback
    messageContentHTML = message.text || '';
  }
  
  // Add reply indicator if message is a reply
  let replyHTML = '';
  if (message.replyTo) {
    const repliedMessage = allMessages.find(m => m.id === message.replyTo);
    if (repliedMessage) {
      let repliedText = repliedMessage.text || '';
      if (repliedMessage.isVoice) {
        repliedText = 'Voice message';
      } else if (repliedMessage.fileUrl) {
        if (repliedMessage.fileType && repliedMessage.fileType.startsWith('image/')) {
          repliedText = 'Image';
        } else if (repliedMessage.fileType && repliedMessage.fileType.startsWith('video/')) {
          repliedText = 'Video';
        } else if (repliedMessage.fileType && repliedMessage.fileType.startsWith('audio/')) {
          repliedText = 'Audio';
        } else {
          repliedText = 'File';
        }
      }
      replyHTML = `
        <div class="message-reply" onclick="scrollToMessage('${message.replyTo}')">
          <div class="reply-indicator">
            <i class="fas fa-reply"></i>
            Replying to ${repliedMessage.userId === currentUser.uid ? 'yourself' : 
              (repliedMessage.isAdmin ? 'Admin' : 'User ' + repliedMessage.userId.substring(0, 6))}
          </div>
          <div class="reply-content ${!repliedMessage.text ? 'media-reply' : ''}">
            ${repliedText.length > 100 ? repliedText.substring(0, 100) + '...' : repliedText}
          </div>
        </div>
      `;
    }
  }
  
  // Show edit/delete buttons only for the user's own non-voice messages
  const showEditButton = message.userId === currentUser.uid && !message.isVoice && message.text;
  
  messageEl.innerHTML = `
    <div class="message-info">
      <div class="message-user">${message.userId === currentUser.uid ? 'You' : (message.isAdmin ? 'Admin' : 'User ' + message.userId.substring(0, 6))}</div>
      <div class="message-time">${timeText}</div>
    </div>
    ${replyHTML}
    <div class="message-content">
      ${messageContentHTML}
      ${message.userId === currentUser.uid ? `
        <div class="message-actions">
          ${showEditButton ? `<button class="message-action edit-btn" data-id="${message.id}"><i class="fas fa-edit"></i></button>` : ''}
          <button class="message-action delete-btn" data-id="${message.id}"><i class="fas fa-trash"></i></button>
        </div>
      ` : ''}
    </div>
  `;
  
  // Append to container + auto-scroll
  messagesContainer.appendChild(messageEl);
  setupReactionsListener(message.id);
  
  // Wire up edit/delete buttons
  if (message.userId === currentUser.uid) {
    if (showEditButton) {
      const editBtn = messageEl.querySelector('.edit-btn');
      editBtn.addEventListener('click', () => {
        editMessage(message.id, message.text);
      });
    }
    
    const deleteBtn = messageEl.querySelector('.delete-btn');
    deleteBtn.addEventListener('click', () => {
      deleteMessage(message.id);
    });
  }
  
  // Scroll to bottom if this is a new message from current user or a reply to current user's message
  const isNewMessage = Date.now() - (message.timestamp?.toDate().getTime() || Date.now()) < 5000;
  if (isNewMessage && (message.userId === currentUser.uid || 
      (currentReplyTo && message.replyTo === currentReplyTo))) {
    setTimeout(() => {
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }, 100);
  }
}

// Edit message
function editMessage(messageId, messageText) {
  messageInput.value = messageText;
  messageInput.focus();
  updateButtonMode(); // Update button based on the text

  editMessageId = messageId;
  editMode.classList.add('active');
}

// Cancel edit
function cancelEdit() {
  editMessageId = null;
  editMode.classList.remove('active');
  messageInput.value = '';
  updateButtonMode(); // Update button after clearing input
}

// Delete message using serverless function
async function deleteMessage(messageId) {
  if (!confirm('Are you sure you want to delete this message?')) {
    return;
  }
  
  try {
    const response = await fetch('/.netlify/functions/delete-message1', {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ 
        messageId, 
        userId: currentUser.uid 
      }),
    });

    const result = await response.json();
    
    if (!response.ok) {
      throw new Error(result.error);
    }

    // Remove from UI
    const messageEl = document.getElementById(`message-${messageId}`);
    if (messageEl) {
      messageEl.remove();
    }

    // Show welcome message if no messages left
    if (messagesContainer.children.length === 0) {
      const welcomeMsg = document.createElement('div');
      welcomeMsg.classList.add('welcome-message');
      welcomeMsg.innerHTML = `
        <i class="fas fa-comments" style="font-size: 24px; margin-bottom: 10px;"></i>
        <p>Welcome to the community chat!</p>
        <p>Start a conversation by typing a message below.</p>
      `;
      messagesContainer.appendChild(welcomeMsg);
    }
    
    showNotification('Message deleted successfully');
  } catch (error) {
    console.error('Error deleting message:', error);
    showNotification('Error: ' + error.message, 'error');
  }
}

// Show notification
function showNotification(message, type = 'info') {
  notification.textContent = message;
  notification.style.background = type === 'error' ? '#f44336' : '#333';
  notification.classList.add('show');

  setTimeout(() => {
    notification.classList.remove('show');
  }, 3000);
}

// Initialize the chat when page loads
window.addEventListener('load', initChat);

// Export functions to global scope for HTML onclick handlers
window.openImageModal = openImageModal;
window.scrollToMessage = scrollToMessage;
</script>
</body>
</html>